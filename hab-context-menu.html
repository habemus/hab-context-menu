<link
  rel="import"
  href="../polymer/polymer.html">
<link
  rel="import"
  href="../iron-overlay-behavior/iron-overlay-behavior.html">

<dom-module id="hab-context-menu">

  <template>

    <style>
      :host {
        /* ensure fixed position so that the menu may be placed anywhere */
        position: fixed;
      }

      /**
       * copied from
       * http://codepen.io/sstephenson/pen/zepwD
       */
      menu {
        display: block;

        margin: 0;
        padding: 3px 0 4px;

        /*background: rgba(255, 255, 255, 0.95);*/
        background-color: white;
        /*box-shadow: 0px 8px 15px rgba(0, 0, 0, 0.35);*/
        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2);
        border-radius: 2px;

        /*font-family: Lucida Grande;*/
        /*font-size: 14px;*/
        /*line-height: 15px;*/
      }

      menu::before {
        display: block;
        position: absolute;
        content: "";
        top: -1px;
        left: -1px;
        bottom: -1px;
        right: -1px;

        border-radius: 2px;
        /*border: 1px solid rgba(0, 0, 0, 0.125);*/
        z-index: -1;
      }

      menu hr {
        border: none;
        height: 1px;
        background: rgba(0, 0, 0, 0.10);
        margin: 6px 1px 5px;
        padding: 0;
      }

      menu menuitem, menu li {
        display: block;
        padding: 0 20px;
        border-top: 1px solid rgba(0, 0, 0, 0);
        border-bottom: 1px solid rgba(0, 0, 0, 0);
      }

      menu menuitem:after, menu li:after {
        vertical-align: 2px;
        content: attr(label);
      }

      menu menuitem:hover, menu li:hover {
        /*background: -webkit-linear-gradient(top, #648bf5, #2866f2);*/
        /*background: linear-gradient(to bottom, #648bf5 0%, #2866f2 100%);*/
        background-color: #bbb;
        /*border-top: 1px solid #5a82eb;*/
        /*border-bottom: 1px solid #1758e7;*/
      }

      menu menuitem:hover:after, menu li:hover:after {
        color: #fff;
      }
      /**
       * copied from
       * http://codepen.io/sstephenson/pen/zepwD
       */

    </style>

    <menu id="menu">
      <template is="dom-repeat" items="{{ options }}">
        <!-- default -->
        <template is="dom-if" if="[[ !item.type ]]">
          <menuitem
            hidden$="{{ _computeItemValue('hide', context, item) }}"
            on-tap="_handleMenuitemTap"
            label$="{{ _computeItemValue('label', context, item) }}">
          </menuitem>
        </template>

        <!-- url -->
        <template is="dom-if" if="[[ _itemIs(item, 'url') ]]">
          <li
            hidden$="{{ _computeItemValue('hide', context, item) }}">
            <a
              on-tap="_handleMenuitemTap"
              target="{{ _computeItemValue('target', context, item) }}"
              href="{{ _computeItemValue('url', context, item) }}">
              {{ _computeItemValue('label', context, item) }}
            </a>
          </li>
        </template>

        <!-- input:file -->
        <template is="dom-if" if="[[ _itemIs(item, 'input:file') ]]">
          <li
            hidden$="{{ _computeItemValue('hide', context, item) }}">
            <input on-change="_handleFileInputChange" type="file">
          </li>
        </template>
      </template>
    </menu>

    <content></content>
  </template>

</dom-module>

<script>

(function() {

  Polymer({

    is: 'hab-context-menu',

    properties: {
      /**
       * Array of context menu options
       */
      options: {
        type: Array,
      },

      /**
       * Holds data about the context of the menu open
       */
      context: {
        type: Object,
      },
      
      /**
       * Defines the x distance from the open position
       * the context menu will be opened
       */
      openOffsetX: {
        type: Number,
        value: 3,
      },
      
      /**
       * Defines the y distance from the open position
       * the context menu will be opened
       */
      openOffsetY: {
        type: Number,
        value: -2,
      },

      /**
       * Minimum distance from the bottom of the window
       * @type {Number}
       */
      bottomMinimumOffset: {
        type: Number,
        value: 10,
      }
    },

    behaviors: [
      Polymer.IronOverlayBehavior
    ],

    ready: function () {
      // setup backdrop
      this.setAttribute('with-backdrop', true);
      // make backdrop traansparent
      this.backdropElement.style.opacity = 0;

      // bind the _handleBackdropContextmenu to this element
      this._handleBackdropContextmenu =
        this._handleBackdropContextmenu.bind(this);
    },

    _handleBackdropContextmenu: function (e) {
      e.preventDefault();
      // close the menu
      this.menuClose();
    },

    /**
     * Menu item clicks
     */
    _handleMenuitemTap: function (e) {
      var data = e.model.item;

      if (typeof data.callback === 'function') {
        data.callback({
          menuElement: this,
          menuOption: data,
          context: this.get('context'),
          event: e,
        });
      } else {
        // no callback defined, run the default behaviour of
        // closing the menu in the next tick so that it does
        // not interfere with the default behavior of the elemnt
        setTimeout(this.menuClose.bind(this), 0);
      }
    },

    /**
     * File input
     */
    _handleFileInputChange: function (e) {
      var data = e.model.item;
      var file = e.target.files[0];

      e.target.value = '';

      if (typeof data.callback === 'function') {
        data.callback({
          menuElement: this,
          menuOption: data,
          context: this.get('context'),
          event: e,

          file: file,
        });
      } else {
        // no callback defined, run the default behaviour of
        // closing the menu in the next tick so that it does
        // not interfere with the default behavior of the elemnt
        setTimeout(this.menuClose.bind(this), 0);
      }
    },

    /**
     * Helper function to check the item type
     */
    _itemIs: function (item, type) {
      return item.type === type;
    },

    _computeItemValue: function (key, context, item) {
      if (!context) {
        return;
      }

      var value = item[key];

      if (typeof value === 'function') {
        value = value({
          menuElement: this,
          menuOption: item,
          context: context,
        });
      }

      return value;
    },

    menuOpenWithContext: function (context, position) {
      if (!context) { throw new Error('context is required'); }
      if (!position) { throw new Error('position is required'); }
      if (typeof position.left !== 'number' || typeof position.top !== 'number') {
        throw new TypeError('position.left and position.top must be numbers');
      }

      // set the context
      this.set('context', context);

      // let the menu resetFit (see IronOverlayBehavior docs)
      this.resetFit();
      
      var menuLeft = position.left + this.openOffsetX;
      var menuTop  = position.top  + this.openOffsetY;

      // at this moment the positioning is not ready yet.
      // make the opacity 0 to hide the element but NOT affect
      // its position calculation
      this.style.opacity = 0;

      this.open();

      // TODO: study deeper why Polymer.dom.flush
      // has no effects on the positioning.
      // We are facing a problem with calculating the
      // boundingRect of the context-menu element.
      // 
      // For the time being, let the positioning be done
      // on the next tick
      // Polymer.dom.flush();

      setTimeout(function () {
        /**
         * All this logic is performed in order to fit
         * the menu within the viewport.
         * It might be a redundant work, as the Polymer
         * IronOverlayBehavior already implements
         * IronFitBehavior.
         *
         * The main issue was that IronFitBehavior
         * was quite hard to use and did not seem to
         * have been designed for use with mouse positions
         * but with element position and aligment instead.
         */

        // check whether the element fits in the window
        var windowHeight = window.innerHeight;
        var menuHeight   = this.$.menu.offsetHeight;

        var bottomDelta = windowHeight - (menuTop + menuHeight + this.bottomMinimumOffset);

        if (bottomDelta < 0) {
          menuTop = menuTop + bottomDelta;
        }

        // set positioning styles
        this.style.left = menuLeft + 'px';
        this.style.top  = menuTop  + 'px';

        // show element
        this.style.opacity = 1;

      }.bind(this), 10)
      
      // let backdropElement close on contextmenu event
      // add this event listener when the menu is opened
      // and remove it when the menu is closed
      this.backdropElement.addEventListener(
        'contextmenu', this._handleBackdropContextmenu);
    },

    menuClose: function () {
      // unset context
      this.set('context', null);

      this.close();
      this.backdropElement.removeEventListener(
        'contextmenu', this._handleBackdropContextmenu);
    },

  });

})();

</script>
